{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Gryd Support this project Buy \u0466 and: [X] Send \u0466 to AUahWfkfr5J4tYakugRbfow7RWVTK35GPW [X] Vote arky on Ark blockchain and earn \u0466 weekly Why this package ? Gryd package provides efficient great circle computation and projection library. Documentation The Gryd Project [WIP] Installation TODO Contribute Bug report & feedback Use project issues. Add / modify / fix code Guidance words: keep it simple and solid! open a issue to propose your contribution once issue is granted fork this repository edit your contribution start a pull request","title":"Home"},{"location":"#gryd","text":"","title":"Gryd"},{"location":"#support-this-project","text":"Buy \u0466 and: [X] Send \u0466 to AUahWfkfr5J4tYakugRbfow7RWVTK35GPW [X] Vote arky on Ark blockchain and earn \u0466 weekly","title":"Support this project"},{"location":"#why-this-package","text":"Gryd package provides efficient great circle computation and projection library.","title":"Why this package ?"},{"location":"#documentation","text":"The Gryd Project [WIP]","title":"Documentation"},{"location":"#installation","text":"TODO","title":"Installation"},{"location":"#contribute","text":"","title":"Contribute"},{"location":"#bug-report-feedback","text":"Use project issues.","title":"Bug report &amp; feedback"},{"location":"#add-modify-fix-code","text":"Guidance words: keep it simple and solid! open a issue to propose your contribution once issue is granted fork this repository edit your contribution start a pull request","title":"Add / modify / fix code"},{"location":"api/","text":"Gryd EPSG dataset All epsg dataset linked to these projections are available through python API using epsg id or name: Mercator Transverse Mercator Lambert Conformal Conic. Oblique Mercator Miller Grids Four main grids are available: Universal Transverse Mercator Military Grid Reference System British National Grid Irish National Grid. Image-map interpolation Gryd.Crs also provides functions for map coordinates interpolation using calibration Points (two minimum are required). Quick view >>> import Gryd >>> dublin = Gryd.Geodesic(-6.259437, 53.350765, 0.) >>> dublin <lon=-006\u00c2\u00b015'33.973\" lat=+053\u00c2\u00b021'2.754\" alt=0.000> >>> utm = Gryd.Crs(epsg=3395, projection=\"utm\") >>> utm(dublin) <area=29U E=682406.211 N=5914792.531, alt=0.000> >>> mgrs = Gryd.Crs(epsg=3395, projection=\"mgrs\") >>> mgrs(dublin) <area=29U PV E=82406.211 N=14792.531, alt=0.000> >>> bng = Gryd.Crs(projection=\"bng\") >>> bng(dublin) <area=SG E=16572.029 N=92252.917, alt=0.000> >>> ing = Gryd.Crs(projection=\"ing\") >>> ing(dublin) <area=O E=15890.887 N=34804.964, alt=0.000> EPSG_CON Connection to epsg database Geocentric Objects class Geocentric(ctypes.Structure) ctypes structure for geocentric coordinates. This reference is generaly used as a transition for datum conversion. Attributes : x float - X-axis value y float - Y-axis value z float - Z-axis value >>> Gryd.Geocentric(4457584, 429216, 4526544) <X=4457584.000 Y=429216.000 Z=4526544.000> >>> Gryd.Geocentric(x=4457584, y=429216, z=4526544) <X=4457584.000 Y=429216.000 Z=4526544.000> Point Objects class Point(ctypes.Structure) ctypes structure for calibration point. It is used for coordinates interpolation on a referenced raster image. Two points minimum are required. Attributes : px float - pixel column position py float - pixel row position lla Gryd.Geodesic - geodesic coordinates associated to the pixel coordinates xya Gryd.Geographic - geographic coordinates associated to the pixel coordinates Vincenty_dist Objects class Vincenty_dist(ctypes.Structure) Great circle distance computation result using Vincenty formulae. Vincenty_dist structures are returned by Gryd.Ellipsoid.distance function. Attributes : distance float - great circle distance in meters initial_bearing float - initial bearing in degrees final_bearing float - final bearing in degrees >>> wgs84 = Gryd.Ellipsoid(name=\"WGS 84\") # WGS 84 ellipsoid >>> london = Gryd.Geodesic(-0.127005, 51.518602, 0.) >>> dublin = Gryd.Geodesic(-6.259437, 53.350765, 0.) >>> vdist = wgs84.distance(dublin, london) >>> vdist <Distance 464.025km initial bearing=113.6 final bearing=118.5> Vincenty_dest Objects class Vincenty_dest(ctypes.Structure) Great circle destination computation result using Vincenty formulae. Vincenty_dist structures are returned by Gryd.Ellipsoid.destination function. Attributes : longitude float - destinatin longitude in degrees latitude float - destination latitude in degrees destination_bearing float - destination bearing in degrees >>> wgs84.destination( ... london, math.degrees(vdist.final_bearing) + 180, vdist.distance ... ) <Destination lon=-006\u00c2\u00b015'33.973\" lat=+053\u00c2\u00b021'2.754\" end bearing=-66.4> >>> dublin <lon=-006\u00c2\u00b015'33.973\" lat=+053\u00c2\u00b021'2.754\" alt=0.000> Dms Objects class Dms(ctypes.Structure) Degrees Minutes Seconde value of a float value. Dms structure are returned by Gryd.dms function. >>> d = Gryd.dms(-60.42286847222222) >>> d -060\u00c2\u00b025'22.326\" >>> float(d) -60.42286847222222 Dmm Objects class Dmm(ctypes.Structure) Degrees Minutes value of a float value. Dmm structure are returned by Gryd.dmm function. >>> d = Gryd.dmm(-60.42286847222222) >>> d -060\u00c2\u00b025.372108' >>> float(d) -60.42286847222222 Epsg Objects class Epsg(ctypes.Structure) ctypes structure with a sqlite connection to EPSG database for initialization purpose. sqlite Shared sqlite database to be linked with table The table database name where __init__ will find data __init__ | __init__(*args, **pairs) If list of values is given as *args , structure members are initialized in the order of the field definition. If *args only contains one value: it is a dict then all fields are initialized it is an int then try to get a record from database using epsg id it is a str then try to get a record from database using epsg name All values in **pairs are merged before attributes initialization. Unit Objects class Unit(Epsg) Unit ratio relative to meter. >>> Gryd.Unit(9001) <Unit epsg=9001 ratio=1.0> >>> Gryd.Unit(epsg=9001).name 'metre' >>> Gryd.Unit(name=\"foot\") <Unit epsg=9002 ratio=3.2808693302666354> >>> float(Gryd.Unit(name=\"foot\")) 3.2808693302666354 Prime Objects class Prime(Epsg) Prime meridian. >>> prime = Gryd.Prime(epsg=8902) >>> prime <Prime meridian epsg=8902 longitude=-009\u00c2\u00b007'54.862\"> >>> prime.name 'Lisbon' Ellipsoid Objects class Ellipsoid(Epsg) >>> wgs84 = Gryd.Ellipsoid(\"WGS 84\") >>> wgs84 <Ellispoid epsg=7030 a=6378137.000000 1/f=298.25722356> distance | distance(lla0, lla1) >>> london = Gryd.Geodesic(-0.127005, 51.518602, 0.) >>> dublin = Gryd.Geodesic(-6.259437, 53.350765, 0.) >>> wgs84.distance(dublin, london) <Distance 464.025km initial bearing=113.6 final bearing=118.5> destination | destination(lla, bearing, distance) >>> wgs84.destination( ... london, math.degrees(vdist.final_bearing)+180, vdist.distance ... ) <Destination lon=-006\u00c2\u00b015'33.973\" lat=+053\u00c2\u00b021'2.754\" end bearing=-66.4> >>> dublin <lon=-006\u00c2\u00b015'33.973\" lat=+053\u00c2\u00b021'2.754\" alt=0.000> npoints | npoints(lla0, lla1, n) >>> for p in wgs84.npoints(dublin, londre, 4): print(p) ... <Destination lon=-006\u00c2\u00b015'33.973\" lat=+053\u00c2\u00b021'2.754\" end bearing=113.6> <Destination lon=-004\u00c2\u00b059'32.422\" lat=+053\u00c2\u00b000'36.687\" end bearing=114.6> <Destination lon=-003\u00c2\u00b044'43.501\" lat=+052\u00c2\u00b039'22.715\" end bearing=115.6> <Destination lon=-002\u00c2\u00b031'7.792\" lat=+052\u00c2\u00b017'22.201\" end bearing=116.6> <Destination lon=-001\u00c2\u00b018'45.650\" lat=+051\u00c2\u00b054'36.502\" end bearing=117.5> <Destination lon=-000\u00c2\u00b007'37.218\" lat=+051\u00c2\u00b031'6.967\" end bearing=118.5> Datum Objects class Datum(Epsg) Gryd.Datum(epsg=4326) <Datum epsg=4326: to wgs84: 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 xyz | xyz(lla) >>> wgs84.xyz(london) <X=3977018.848 Y=-8815.695 Z=4969650.564> lla | lla(xyz) >>> wgs84.lla(wgs84.xyz(london)) <lon=-000\u00c2\u00b007'37.218\" lat=+051\u00c2\u00b031'6.967\" alt=0.000> >>> london <lon=-000\u00c2\u00b007'37.218\" lat=+051\u00c2\u00b031'6.967\" alt=0.000> transform | transform(dst, lla) >>> airy = Gryd.Datum(epsg=4277) >>> wgs84.transform(airy, london) <lon=-000\u00c2\u00b007'31.431'' lat=+051\u00c2\u00b031'5.137'' alt=-46.118> Crs Objects class Crs(Epsg) >>> pvs = Gryd.Crs(epsg=3785) >>> osgb36 = Gryd.Crs(epsg=27700) >>> osgb36.datum.xyz(london) <X=3976632.017 Y=-8814.837 Z=4969286.446> >>> osgb36.datum.ellipsoid.distance(dublin, london) <Distance 463.981km initial bearing=113.6 final bearing=118.5> >>> osgb36 <Crs epsg=27700: <Datum epsg=4277: <Ellispoid epsg=7001 a=6377563.396000 1/f=299.32496460> <Prime meridian epsg=8901 longitude=0.000000> to wgs84 446.45,-125.16,542.06,-20.49,0.15,0.25,0.84> > <Unit epsg=9001 ratio=1.0> <Projection 'tmerc'> > __call__ | __call__(element) >>> osgb36(london) # projection of Geodesic point <X=529939.106 Y=181680.962s alt=0.000> >>> osgb36(osgb36(london)) # deprojection of Geographic point <lon=-000\u00c2\u00b007'37.218\" lat=+051\u00c2\u00b031'6.967\" alt=0.000> transform | transform(dst, xya) >>> osgb36.transform(pvs, osgb36(london)) <X=-14317.072 Y=6680144.273s alt=-13015.770> >>> pvs.transform(osgb36, osgb36.transform(pvs, osgb36(london))) <X=529939.101 Y=181680.963s alt=0.012> >>> osgb36(london) <X=529939.106 Y=181680.962s alt=0.000> add_map_point | add_map_point(px, py, point) >>> pvs.add_map_point(0,0, Geodesic(-179.999, 85)) >>> pvs.add_map_point(512,512, Geodesic(179.999, -85)) map2crs | map2crs(px, py, geographic=False) >>> pvs.map2crs(256+128, 256+128) <lon=+089\u00c2\u00b059'58.20'' lat=-066\u00c2\u00b023'43.74'' alt=0.000> >>> pvs.map2crs(256-128, 256+128, geographic=True) <point X=-10018698.512 Y=-9985934.440s alt=0.000> crs2map | crs2map(point) >>> pvs.crs2map(pvs.map2crs(256+128, 256+128)) <px=384 py=384 - <lon=+089\u00c2\u00b059'58.20'' lat=-066\u00c2\u00b023'43.74'' alt=0.000> - <X=10018698.512 Y=-9985934.440s alt=0.000> >","title":"API"},{"location":"api/#gryd","text":"EPSG dataset All epsg dataset linked to these projections are available through python API using epsg id or name: Mercator Transverse Mercator Lambert Conformal Conic. Oblique Mercator Miller Grids Four main grids are available: Universal Transverse Mercator Military Grid Reference System British National Grid Irish National Grid. Image-map interpolation Gryd.Crs also provides functions for map coordinates interpolation using calibration Points (two minimum are required). Quick view >>> import Gryd >>> dublin = Gryd.Geodesic(-6.259437, 53.350765, 0.) >>> dublin <lon=-006\u00c2\u00b015'33.973\" lat=+053\u00c2\u00b021'2.754\" alt=0.000> >>> utm = Gryd.Crs(epsg=3395, projection=\"utm\") >>> utm(dublin) <area=29U E=682406.211 N=5914792.531, alt=0.000> >>> mgrs = Gryd.Crs(epsg=3395, projection=\"mgrs\") >>> mgrs(dublin) <area=29U PV E=82406.211 N=14792.531, alt=0.000> >>> bng = Gryd.Crs(projection=\"bng\") >>> bng(dublin) <area=SG E=16572.029 N=92252.917, alt=0.000> >>> ing = Gryd.Crs(projection=\"ing\") >>> ing(dublin) <area=O E=15890.887 N=34804.964, alt=0.000>","title":"Gryd"},{"location":"api/#epsg_con","text":"Connection to epsg database","title":"EPSG_CON"},{"location":"api/#geocentric-objects","text":"class Geocentric(ctypes.Structure) ctypes structure for geocentric coordinates. This reference is generaly used as a transition for datum conversion. Attributes : x float - X-axis value y float - Y-axis value z float - Z-axis value >>> Gryd.Geocentric(4457584, 429216, 4526544) <X=4457584.000 Y=429216.000 Z=4526544.000> >>> Gryd.Geocentric(x=4457584, y=429216, z=4526544) <X=4457584.000 Y=429216.000 Z=4526544.000>","title":"Geocentric Objects"},{"location":"api/#point-objects","text":"class Point(ctypes.Structure) ctypes structure for calibration point. It is used for coordinates interpolation on a referenced raster image. Two points minimum are required. Attributes : px float - pixel column position py float - pixel row position lla Gryd.Geodesic - geodesic coordinates associated to the pixel coordinates xya Gryd.Geographic - geographic coordinates associated to the pixel coordinates","title":"Point Objects"},{"location":"api/#vincenty_dist-objects","text":"class Vincenty_dist(ctypes.Structure) Great circle distance computation result using Vincenty formulae. Vincenty_dist structures are returned by Gryd.Ellipsoid.distance function. Attributes : distance float - great circle distance in meters initial_bearing float - initial bearing in degrees final_bearing float - final bearing in degrees >>> wgs84 = Gryd.Ellipsoid(name=\"WGS 84\") # WGS 84 ellipsoid >>> london = Gryd.Geodesic(-0.127005, 51.518602, 0.) >>> dublin = Gryd.Geodesic(-6.259437, 53.350765, 0.) >>> vdist = wgs84.distance(dublin, london) >>> vdist <Distance 464.025km initial bearing=113.6 final bearing=118.5>","title":"Vincenty_dist Objects"},{"location":"api/#vincenty_dest-objects","text":"class Vincenty_dest(ctypes.Structure) Great circle destination computation result using Vincenty formulae. Vincenty_dist structures are returned by Gryd.Ellipsoid.destination function. Attributes : longitude float - destinatin longitude in degrees latitude float - destination latitude in degrees destination_bearing float - destination bearing in degrees >>> wgs84.destination( ... london, math.degrees(vdist.final_bearing) + 180, vdist.distance ... ) <Destination lon=-006\u00c2\u00b015'33.973\" lat=+053\u00c2\u00b021'2.754\" end bearing=-66.4> >>> dublin <lon=-006\u00c2\u00b015'33.973\" lat=+053\u00c2\u00b021'2.754\" alt=0.000>","title":"Vincenty_dest Objects"},{"location":"api/#dms-objects","text":"class Dms(ctypes.Structure) Degrees Minutes Seconde value of a float value. Dms structure are returned by Gryd.dms function. >>> d = Gryd.dms(-60.42286847222222) >>> d -060\u00c2\u00b025'22.326\" >>> float(d) -60.42286847222222","title":"Dms Objects"},{"location":"api/#dmm-objects","text":"class Dmm(ctypes.Structure) Degrees Minutes value of a float value. Dmm structure are returned by Gryd.dmm function. >>> d = Gryd.dmm(-60.42286847222222) >>> d -060\u00c2\u00b025.372108' >>> float(d) -60.42286847222222","title":"Dmm Objects"},{"location":"api/#epsg-objects","text":"class Epsg(ctypes.Structure) ctypes structure with a sqlite connection to EPSG database for initialization purpose.","title":"Epsg Objects"},{"location":"api/#sqlite","text":"Shared sqlite database to be linked with","title":"sqlite"},{"location":"api/#table","text":"The table database name where __init__ will find data","title":"table"},{"location":"api/#__init__","text":"| __init__(*args, **pairs) If list of values is given as *args , structure members are initialized in the order of the field definition. If *args only contains one value: it is a dict then all fields are initialized it is an int then try to get a record from database using epsg id it is a str then try to get a record from database using epsg name All values in **pairs are merged before attributes initialization.","title":"__init__"},{"location":"api/#unit-objects","text":"class Unit(Epsg) Unit ratio relative to meter. >>> Gryd.Unit(9001) <Unit epsg=9001 ratio=1.0> >>> Gryd.Unit(epsg=9001).name 'metre' >>> Gryd.Unit(name=\"foot\") <Unit epsg=9002 ratio=3.2808693302666354> >>> float(Gryd.Unit(name=\"foot\")) 3.2808693302666354","title":"Unit Objects"},{"location":"api/#prime-objects","text":"class Prime(Epsg) Prime meridian. >>> prime = Gryd.Prime(epsg=8902) >>> prime <Prime meridian epsg=8902 longitude=-009\u00c2\u00b007'54.862\"> >>> prime.name 'Lisbon'","title":"Prime Objects"},{"location":"api/#ellipsoid-objects","text":"class Ellipsoid(Epsg) >>> wgs84 = Gryd.Ellipsoid(\"WGS 84\") >>> wgs84 <Ellispoid epsg=7030 a=6378137.000000 1/f=298.25722356>","title":"Ellipsoid Objects"},{"location":"api/#distance","text":"| distance(lla0, lla1) >>> london = Gryd.Geodesic(-0.127005, 51.518602, 0.) >>> dublin = Gryd.Geodesic(-6.259437, 53.350765, 0.) >>> wgs84.distance(dublin, london) <Distance 464.025km initial bearing=113.6 final bearing=118.5>","title":"distance"},{"location":"api/#destination","text":"| destination(lla, bearing, distance) >>> wgs84.destination( ... london, math.degrees(vdist.final_bearing)+180, vdist.distance ... ) <Destination lon=-006\u00c2\u00b015'33.973\" lat=+053\u00c2\u00b021'2.754\" end bearing=-66.4> >>> dublin <lon=-006\u00c2\u00b015'33.973\" lat=+053\u00c2\u00b021'2.754\" alt=0.000>","title":"destination"},{"location":"api/#npoints","text":"| npoints(lla0, lla1, n) >>> for p in wgs84.npoints(dublin, londre, 4): print(p) ... <Destination lon=-006\u00c2\u00b015'33.973\" lat=+053\u00c2\u00b021'2.754\" end bearing=113.6> <Destination lon=-004\u00c2\u00b059'32.422\" lat=+053\u00c2\u00b000'36.687\" end bearing=114.6> <Destination lon=-003\u00c2\u00b044'43.501\" lat=+052\u00c2\u00b039'22.715\" end bearing=115.6> <Destination lon=-002\u00c2\u00b031'7.792\" lat=+052\u00c2\u00b017'22.201\" end bearing=116.6> <Destination lon=-001\u00c2\u00b018'45.650\" lat=+051\u00c2\u00b054'36.502\" end bearing=117.5> <Destination lon=-000\u00c2\u00b007'37.218\" lat=+051\u00c2\u00b031'6.967\" end bearing=118.5>","title":"npoints"},{"location":"api/#datum-objects","text":"class Datum(Epsg) Gryd.Datum(epsg=4326) <Datum epsg=4326: to wgs84: 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0","title":"Datum Objects"},{"location":"api/#xyz","text":"| xyz(lla) >>> wgs84.xyz(london) <X=3977018.848 Y=-8815.695 Z=4969650.564>","title":"xyz"},{"location":"api/#lla","text":"| lla(xyz) >>> wgs84.lla(wgs84.xyz(london)) <lon=-000\u00c2\u00b007'37.218\" lat=+051\u00c2\u00b031'6.967\" alt=0.000> >>> london <lon=-000\u00c2\u00b007'37.218\" lat=+051\u00c2\u00b031'6.967\" alt=0.000>","title":"lla"},{"location":"api/#transform","text":"| transform(dst, lla) >>> airy = Gryd.Datum(epsg=4277) >>> wgs84.transform(airy, london) <lon=-000\u00c2\u00b007'31.431'' lat=+051\u00c2\u00b031'5.137'' alt=-46.118>","title":"transform"},{"location":"api/#crs-objects","text":"class Crs(Epsg) >>> pvs = Gryd.Crs(epsg=3785) >>> osgb36 = Gryd.Crs(epsg=27700) >>> osgb36.datum.xyz(london) <X=3976632.017 Y=-8814.837 Z=4969286.446> >>> osgb36.datum.ellipsoid.distance(dublin, london) <Distance 463.981km initial bearing=113.6 final bearing=118.5> >>> osgb36 <Crs epsg=27700: <Datum epsg=4277: <Ellispoid epsg=7001 a=6377563.396000 1/f=299.32496460> <Prime meridian epsg=8901 longitude=0.000000> to wgs84 446.45,-125.16,542.06,-20.49,0.15,0.25,0.84> > <Unit epsg=9001 ratio=1.0> <Projection 'tmerc'> >","title":"Crs Objects"},{"location":"api/#__call__","text":"| __call__(element) >>> osgb36(london) # projection of Geodesic point <X=529939.106 Y=181680.962s alt=0.000> >>> osgb36(osgb36(london)) # deprojection of Geographic point <lon=-000\u00c2\u00b007'37.218\" lat=+051\u00c2\u00b031'6.967\" alt=0.000>","title":"__call__"},{"location":"api/#transform_1","text":"| transform(dst, xya) >>> osgb36.transform(pvs, osgb36(london)) <X=-14317.072 Y=6680144.273s alt=-13015.770> >>> pvs.transform(osgb36, osgb36.transform(pvs, osgb36(london))) <X=529939.101 Y=181680.963s alt=0.012> >>> osgb36(london) <X=529939.106 Y=181680.962s alt=0.000>","title":"transform"},{"location":"api/#add_map_point","text":"| add_map_point(px, py, point) >>> pvs.add_map_point(0,0, Geodesic(-179.999, 85)) >>> pvs.add_map_point(512,512, Geodesic(179.999, -85))","title":"add_map_point"},{"location":"api/#map2crs","text":"| map2crs(px, py, geographic=False) >>> pvs.map2crs(256+128, 256+128) <lon=+089\u00c2\u00b059'58.20'' lat=-066\u00c2\u00b023'43.74'' alt=0.000> >>> pvs.map2crs(256-128, 256+128, geographic=True) <point X=-10018698.512 Y=-9985934.440s alt=0.000>","title":"map2crs"},{"location":"api/#crs2map","text":"| crs2map(point) >>> pvs.crs2map(pvs.map2crs(256+128, 256+128)) <px=384 py=384 - <lon=+089\u00c2\u00b059'58.20'' lat=-066\u00c2\u00b023'43.74'' alt=0.000> - <X=10018698.512 Y=-9985934.440s alt=0.000> >","title":"crs2map"},{"location":"geodesy/","text":"Gryd.geodesy Geodesic Objects class Geodesic(ctypes.Structure) ctypes structure for geodesic coordinates Attributes : longitude latitude altitude >>> dublin = Gryd.Geodesic(-6.272877, 53.344606, 0.) >>> dublin >>> Gryd.Geodesic(45.5, 5.5, 105) __init__ | __init__(*args, **kwargs) Angular value must be given in degree here (more human values). Geohash | Geohash(digit=10, base=\"0123456789bcdefghjkmnpqrstuvwxyz\") Convert coordinates to geohash. dublin.Geohash() # by default on 10 digit for metric precision gc7x3r04z7 dublin.Geohash(14) # why not on 14 digit for millimetric precision gc7x3r04z77csw Maidenhead | Maidenhead(level=4) Convert coordinates to maidenhead. dublin.Maidenhead() 'IO63ui72gq' dublin.Maidenhead(level=6) 'IO63ui72gq19dh' Georef | Georef(digit=8) Convert coordinates to georef. dublin.Georef() 'MKJJ43322037' dublin.Georef(digit=6) 'MKJJ433203' Gars | Gars() Get the associated GARS Area. dublin.Gars() '348MY16' from_geohash from_geohash(geohash, base=\"0123456789bcdefghjkmnpqrstuvwxyz\") return Geodesic object from geohash from_maidenhead from_maidenhead(maidenhead) Return Geodesic object from maidenhead. from_georef from_georef(georef) Return Geodesic object from georef. from_gars from_gars(gars, anchor=\"\") Return Geodesic object from gars. Optional anchor value to define where to handle 5minx5min tile. Gryd.geohash Efficient geohash computing library based on bitwise operation with python integer. >>> from Gryd import geohash >>> dublin = geohash.geoh(-6.272877, 53.344606, bits=50) >>> dublin <01111010110011111101000111011100000001001111100111> >>> geohash.as_str(dublin) 'gc7x3r04z7' >>> geohash.geohash(-6.272877, 53.344606, digit=10) 'gc7x3r04z7' Geohash can be encoded with a custom 32-element-sized base. >>> import random >>> base = list(\"0123456789bcdefghjkmnpqrstuvwxyz\") >>> random.shuffle(base) >>> base = \"\".join(base) >>> base 'tjcbwq2uev8n7r9gmdf1sy05kzxh4p63' >>> geohash.geohash(-6.272877, 53.344606, digit=10, base=base) 'gnupb5tw3u' EARTH_RADIUS Popular Visualisation Spheroid radius (epsg 7059 ellipsoid) GeoH Objects class GeoH(int) Integer that keeps info about leading zero bits. precision | precision() Return metter precision tuple for longitude and latitude based on Popular Visualisation Spheroid radius (epsg 7059 ellipsoid). geoh geoh(lon, lat, bits=25) Return a python integer representing geohashed coordinates longitude and latitude with a given precision. Arguments : lon float - longitude lat float - latitude bits int - length of the geohash in bit Returns : Gryd.geohash.GeoH lonlat lonlat(value, centered=False) Return longitude and latitude and precision from a geohash integer. Arguments : value Gryd.geohash.GeoH or int - geohash value centered bool - returns bottom-left corner (if False ) or center (if True ) of geohash surface Returns : longitude, latitude and precision as (dlon, dlat) tuple to_geohash backward compatibility from_geohash backward compatibility","title":"Geodesy"},{"location":"geodesy/#grydgeodesy","text":"","title":"Gryd.geodesy"},{"location":"geodesy/#geodesic-objects","text":"class Geodesic(ctypes.Structure) ctypes structure for geodesic coordinates Attributes : longitude latitude altitude >>> dublin = Gryd.Geodesic(-6.272877, 53.344606, 0.) >>> dublin >>> Gryd.Geodesic(45.5, 5.5, 105)","title":"Geodesic Objects"},{"location":"geodesy/#__init__","text":"| __init__(*args, **kwargs) Angular value must be given in degree here (more human values).","title":"__init__"},{"location":"geodesy/#geohash","text":"| Geohash(digit=10, base=\"0123456789bcdefghjkmnpqrstuvwxyz\") Convert coordinates to geohash. dublin.Geohash() # by default on 10 digit for metric precision gc7x3r04z7 dublin.Geohash(14) # why not on 14 digit for millimetric precision gc7x3r04z77csw","title":"Geohash"},{"location":"geodesy/#maidenhead","text":"| Maidenhead(level=4) Convert coordinates to maidenhead. dublin.Maidenhead() 'IO63ui72gq' dublin.Maidenhead(level=6) 'IO63ui72gq19dh'","title":"Maidenhead"},{"location":"geodesy/#georef","text":"| Georef(digit=8) Convert coordinates to georef. dublin.Georef() 'MKJJ43322037' dublin.Georef(digit=6) 'MKJJ433203'","title":"Georef"},{"location":"geodesy/#gars","text":"| Gars() Get the associated GARS Area. dublin.Gars() '348MY16'","title":"Gars"},{"location":"geodesy/#from_geohash","text":"from_geohash(geohash, base=\"0123456789bcdefghjkmnpqrstuvwxyz\") return Geodesic object from geohash","title":"from_geohash"},{"location":"geodesy/#from_maidenhead","text":"from_maidenhead(maidenhead) Return Geodesic object from maidenhead.","title":"from_maidenhead"},{"location":"geodesy/#from_georef","text":"from_georef(georef) Return Geodesic object from georef.","title":"from_georef"},{"location":"geodesy/#from_gars","text":"from_gars(gars, anchor=\"\") Return Geodesic object from gars. Optional anchor value to define where to handle 5minx5min tile.","title":"from_gars"},{"location":"geodesy/#grydgeohash","text":"Efficient geohash computing library based on bitwise operation with python integer. >>> from Gryd import geohash >>> dublin = geohash.geoh(-6.272877, 53.344606, bits=50) >>> dublin <01111010110011111101000111011100000001001111100111> >>> geohash.as_str(dublin) 'gc7x3r04z7' >>> geohash.geohash(-6.272877, 53.344606, digit=10) 'gc7x3r04z7' Geohash can be encoded with a custom 32-element-sized base. >>> import random >>> base = list(\"0123456789bcdefghjkmnpqrstuvwxyz\") >>> random.shuffle(base) >>> base = \"\".join(base) >>> base 'tjcbwq2uev8n7r9gmdf1sy05kzxh4p63' >>> geohash.geohash(-6.272877, 53.344606, digit=10, base=base) 'gnupb5tw3u'","title":"Gryd.geohash"},{"location":"geodesy/#earth_radius","text":"Popular Visualisation Spheroid radius (epsg 7059 ellipsoid)","title":"EARTH_RADIUS"},{"location":"geodesy/#geoh-objects","text":"class GeoH(int) Integer that keeps info about leading zero bits.","title":"GeoH Objects"},{"location":"geodesy/#precision","text":"| precision() Return metter precision tuple for longitude and latitude based on Popular Visualisation Spheroid radius (epsg 7059 ellipsoid).","title":"precision"},{"location":"geodesy/#geoh","text":"geoh(lon, lat, bits=25) Return a python integer representing geohashed coordinates longitude and latitude with a given precision. Arguments : lon float - longitude lat float - latitude bits int - length of the geohash in bit Returns : Gryd.geohash.GeoH","title":"geoh"},{"location":"geodesy/#lonlat","text":"lonlat(value, centered=False) Return longitude and latitude and precision from a geohash integer. Arguments : value Gryd.geohash.GeoH or int - geohash value centered bool - returns bottom-left corner (if False ) or center (if True ) of geohash surface Returns : longitude, latitude and precision as (dlon, dlat) tuple","title":"lonlat"},{"location":"geodesy/#to_geohash","text":"backward compatibility","title":"to_geohash"},{"location":"geodesy/#from_geohash_1","text":"backward compatibility","title":"from_geohash"},{"location":"grids/","text":"Gryd.bng Copyright\u00c2\u00a9 2015-2016, THOORENS Bruno All rights reserved Gryd.ing Copyright\u00c2\u00a9 2015-2016, THOORENS Bruno All rights reserved Gryd.mgrs Copyright\u00c2\u00a9 2015-2016, THOORENS Bruno All rights reserved Gryd.utm Copyright\u00c2\u00a9 2015-2016, THOORENS Bruno All rights reserved","title":"Grids"},{"location":"grids/#grydbng","text":"Copyright\u00c2\u00a9 2015-2016, THOORENS Bruno All rights reserved","title":"Gryd.bng"},{"location":"grids/#gryding","text":"Copyright\u00c2\u00a9 2015-2016, THOORENS Bruno All rights reserved","title":"Gryd.ing"},{"location":"grids/#grydmgrs","text":"Copyright\u00c2\u00a9 2015-2016, THOORENS Bruno All rights reserved","title":"Gryd.mgrs"},{"location":"grids/#grydutm","text":"Copyright\u00c2\u00a9 2015-2016, THOORENS Bruno All rights reserved","title":"Gryd.utm"}]}