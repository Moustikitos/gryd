{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Gryd Support this project Buy \u0466 and: [X] Send \u0466 to AUahWfkfr5J4tYakugRbfow7RWVTK35GPW [X] Vote arky on Ark blockchain and earn \u0466 weekly Why this package ? Gryd package provides efficient great circle computation and projection library. Documentation The Gryd Project [WIP] Installation from source distribution $ python setup.py install from pip $ python -m pip install Gryd Contribute Bug report & feedback Use project issues. Add / modify / fix code Guidance words: keep it simple and solid! open a issue to propose your contribution once issue is granted fork this repository edit your contribution start a pull request History 2.0.0 documentation API change binary source release dump location api change geohash module improvement implementation based on python integers better encryption interface 1.2.0 added geohash module 1.1.1 Geodesic class can now dump thumbanil location from google staticmap API bugfix in unit usage for classic projection (other than grid) 1.1.0 projection core changes (simpler & faster) added miller and eqc projection 64 bit support for Windows encrypt/decrypt geodesic coordinates >>> point = Gryd.Geodesic(-6.23, 53.63) >>> point.encrypt(\"your encryption key\") 'mwszncbe9g2tu29' >>> Gryd.decrypt('mwszncbe9g2tu29', key=\"hacking...\") # gives coordinates but not the good ones Geodesic point lon=+025\u00b022'0.011'' lat=-086\u00b036'35.290'' alt=0.000 >>> Gryd.decrypt('mwszncbe9g2tu29', key=\"your encryption key\") Geodesic point lon=-006\u00b013'48.000'' lat=+053\u00b037'48.000'' alt=0.000 >>> point Geodesic point lon=-006\u00b013'48.000'' lat=+053\u00b037'48.000'' alt=0.000 1.0.11 bugfix for mgrs.inverse function utm and mgrs grid tweaks 1.0.10 Gryd.Geodesic exports itself in geohash , maidenhead , georef and gars Gryd.Geodesic created from geohash , maidenhead , georef and gars 1.0.9 bng and ing grid tweaks 1.0.8 bugfix for utm and mgrs grid computation Crs.unit value is now used in computation 1.0.7 Provide a multiplatform wheel (32 and 64 bit for Windows and Ubuntu) Python sources released 1.0.6 Added API doc 1.0.5 All Gryd objects are pickle-able >>> import pickle >>> data = pickle.dumps(wgs84) >>> data b'\\x80\\x03c_ctypes\\n_unpickle\\nq\\x00cGryd\\nEllipsoid\\nq\\x01}q\\x02X\\x04\\x00\\x00\\x00nameq\\x03X\\x06\\x00\\x00\\x00WGS 84q\\x04sC(v\\x1b\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00@\\xa6TXA\\xd0\\x97\\x1c\\x14\\xc4?XA\\x9a\\xaf\\xda<\\x1a\\xf2\\xb4?(\\xe1\\xf3\\x84Zwk?q\\x05\\x86q\\x06\\x86q\\x07Rq\\x08.' >>> pickle.loads(data) Ellispoid epsg=7030 a=6378137.000000 1/f=298.25722356 1.0.4 bugfix Gryd.Vincenty_dest representation wheel distribution fix 1.0.3 linux (ubuntu) fix 1.0.2 Gryd.Geodesic class takes degrees arguments for longitude and latitude values better objects representation speed improvement added __float__ operator for Gryd.Dms and Gryd.Dmm objects >>> float(Gryd.Dms(1, 5, 45, 23)) 5.756388888888889 >>> \"%.6f\" % Gryd.Dms(-1, 5, 45, 23) '-5.756389' 1.0.1 minor changes in C extensions bugfix geoid.dms and geoid.dmm function 1.0.0 first public binary release ( win32 and linux platform)","title":"Home"},{"location":"#gryd","text":"","title":"Gryd"},{"location":"#support-this-project","text":"Buy \u0466 and: [X] Send \u0466 to AUahWfkfr5J4tYakugRbfow7RWVTK35GPW [X] Vote arky on Ark blockchain and earn \u0466 weekly","title":"Support this project"},{"location":"#why-this-package","text":"Gryd package provides efficient great circle computation and projection library.","title":"Why this package ?"},{"location":"#documentation","text":"The Gryd Project [WIP]","title":"Documentation"},{"location":"#installation","text":"","title":"Installation"},{"location":"#from-source-distribution","text":"$ python setup.py install","title":"from source distribution"},{"location":"#from-pip","text":"$ python -m pip install Gryd","title":"from pip"},{"location":"#contribute","text":"","title":"Contribute"},{"location":"#bug-report-feedback","text":"Use project issues.","title":"Bug report &amp; feedback"},{"location":"#add-modify-fix-code","text":"Guidance words: keep it simple and solid! open a issue to propose your contribution once issue is granted fork this repository edit your contribution start a pull request","title":"Add / modify / fix code"},{"location":"#history","text":"","title":"History"},{"location":"#200","text":"documentation API change binary source release dump location api change geohash module improvement implementation based on python integers better encryption interface","title":"2.0.0"},{"location":"#120","text":"added geohash module","title":"1.2.0"},{"location":"#111","text":"Geodesic class can now dump thumbanil location from google staticmap API bugfix in unit usage for classic projection (other than grid)","title":"1.1.1"},{"location":"#110","text":"projection core changes (simpler & faster) added miller and eqc projection 64 bit support for Windows encrypt/decrypt geodesic coordinates >>> point = Gryd.Geodesic(-6.23, 53.63) >>> point.encrypt(\"your encryption key\") 'mwszncbe9g2tu29' >>> Gryd.decrypt('mwszncbe9g2tu29', key=\"hacking...\") # gives coordinates but not the good ones Geodesic point lon=+025\u00b022'0.011'' lat=-086\u00b036'35.290'' alt=0.000 >>> Gryd.decrypt('mwszncbe9g2tu29', key=\"your encryption key\") Geodesic point lon=-006\u00b013'48.000'' lat=+053\u00b037'48.000'' alt=0.000 >>> point Geodesic point lon=-006\u00b013'48.000'' lat=+053\u00b037'48.000'' alt=0.000","title":"1.1.0"},{"location":"#1011","text":"bugfix for mgrs.inverse function utm and mgrs grid tweaks","title":"1.0.11"},{"location":"#1010","text":"Gryd.Geodesic exports itself in geohash , maidenhead , georef and gars Gryd.Geodesic created from geohash , maidenhead , georef and gars","title":"1.0.10"},{"location":"#109","text":"bng and ing grid tweaks","title":"1.0.9"},{"location":"#108","text":"bugfix for utm and mgrs grid computation Crs.unit value is now used in computation","title":"1.0.8"},{"location":"#107","text":"Provide a multiplatform wheel (32 and 64 bit for Windows and Ubuntu) Python sources released","title":"1.0.7"},{"location":"#106","text":"Added API doc","title":"1.0.6"},{"location":"#105","text":"All Gryd objects are pickle-able >>> import pickle >>> data = pickle.dumps(wgs84) >>> data b'\\x80\\x03c_ctypes\\n_unpickle\\nq\\x00cGryd\\nEllipsoid\\nq\\x01}q\\x02X\\x04\\x00\\x00\\x00nameq\\x03X\\x06\\x00\\x00\\x00WGS 84q\\x04sC(v\\x1b\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00@\\xa6TXA\\xd0\\x97\\x1c\\x14\\xc4?XA\\x9a\\xaf\\xda<\\x1a\\xf2\\xb4?(\\xe1\\xf3\\x84Zwk?q\\x05\\x86q\\x06\\x86q\\x07Rq\\x08.' >>> pickle.loads(data) Ellispoid epsg=7030 a=6378137.000000 1/f=298.25722356","title":"1.0.5"},{"location":"#104","text":"bugfix Gryd.Vincenty_dest representation wheel distribution fix","title":"1.0.4"},{"location":"#103","text":"linux (ubuntu) fix","title":"1.0.3"},{"location":"#102","text":"Gryd.Geodesic class takes degrees arguments for longitude and latitude values better objects representation speed improvement added __float__ operator for Gryd.Dms and Gryd.Dmm objects >>> float(Gryd.Dms(1, 5, 45, 23)) 5.756388888888889 >>> \"%.6f\" % Gryd.Dms(-1, 5, 45, 23) '-5.756389'","title":"1.0.2"},{"location":"#101","text":"minor changes in C extensions bugfix geoid.dms and geoid.dmm function","title":"1.0.1"},{"location":"#100","text":"first public binary release ( win32 and linux platform)","title":"1.0.0"},{"location":"api/","text":"Gryd EPSG dataset All epsg dataset linked to these projections are available through python API using epsg id or name: Mercator Transverse Mercator Lambert Conformal Conic. Miller Grids Four main grids are available: Universal Transverse Mercator Military Grid Reference System British National Grid Irish National Grid. Image-map interpolation Gryd.Crs also provides functions for map coordinates interpolation using calibration Points (two minimum are required). Quick view >>> import Gryd >>> dublin = Gryd.Geodesic(-6.259437, 53.350765, 0.) >>> dublin <lon=-006\u00c2\u00b015'33.973\" lat=+053\u00c2\u00b021'2.754\" alt=0.000> >>> utm = Gryd.Crs(epsg=3395, projection=\"utm\") >>> utm(dublin) <area=29U E=682406.211 N=5914792.531, alt=0.000> >>> mgrs = Gryd.Crs(epsg=3395, projection=\"mgrs\") >>> mgrs(dublin) <area=29U PV E=82406.211 N=14792.531, alt=0.000> >>> bng = Gryd.Crs(projection=\"bng\") >>> bng(dublin) <area=SG E=16572.029 N=92252.917, alt=0.000> >>> ing = Gryd.Crs(projection=\"ing\") >>> ing(dublin) <area=O E=15890.887 N=34804.964, alt=0.000> EPSG_CON Connection to epsg database Geocentric Objects class Geocentric(ctypes.Structure) ctypes structure for geocentric coordinates. This reference is generaly used as a transition for datum conversion. Attributes : x float - X-axis value y float - Y-axis value z float - Z-axis value >>> Gryd.Geocentric(4457584, 429216, 4526544) <X=4457584.000 Y=429216.000 Z=4526544.000> >>> Gryd.Geocentric(x=4457584, y=429216, z=4526544) <X=4457584.000 Y=429216.000 Z=4526544.000> Point Objects class Point(ctypes.Structure) ctypes structure for calibration point. It is used for coordinates interpolation on a referenced raster image. Two points minimum are required. Attributes : px float - pixel column position py float - pixel row position lla Gryd.Geodesic - geodesic coordinates associated to the pixel coordinates xya Gryd.Geographic - geographic coordinates associated to the pixel coordinates Vincenty_dist Objects class Vincenty_dist(ctypes.Structure) Great circle distance computation result using Vincenty formulae. Vincenty_dist structures are returned by Gryd.Ellipsoid.distance function. Attributes : distance float - great circle distance in meters initial_bearing float - initial bearing in degrees final_bearing float - final bearing in degrees Vincenty_dest Objects class Vincenty_dest(ctypes.Structure) Great circle destination computation result using Vincenty formulae. Vincenty_dist structures are returned by Gryd.Ellipsoid.destination function. Attributes : longitude float - destinatin longitude in degrees latitude float - destination latitude in degrees destination_bearing float - destination bearing in degrees Dms Objects class Dms(ctypes.Structure) Degrees Minutes Seconde value of a float value. Dms structure are returned by Gryd.dms function. >>> d = Gryd.dms(-60.42286847222222) >>> d -060\u00c2\u00b025'22.326\" >>> float(d) -60.42286847222222 Dmm Objects class Dmm(ctypes.Structure) Degrees Minutes value of a float value. Dmm structure are returned by Gryd.dmm function. >>> d = Gryd.dmm(-60.42286847222222) >>> d -060\u00c2\u00b025.372108' >>> float(d) -60.42286847222222 Epsg Objects class Epsg(ctypes.Structure) ctypes structure with a sqlite connection to EPSG database for initialization purpose. sqlite Shared sqlite database to be linked with table The table database name where __init__ will find data __init__ | __init__(*args, **pairs) If list of values is given as *args , structure members are initialized in the order of the field definition. If *args only contains one value: it is a dict then it is used as a reccord it is an int then try to get a record from database using epsg id it is a str then try to get a record from database using epsg name All values in **pairs are merged in the record before attributes initialization. Unit Objects class Unit(Epsg) Unit ratio relative to meter. >>> Gryd.Unit(9001) <Unit epsg=9001 ratio=1.0> >>> Gryd.Unit(epsg=9001).name 'metre' >>> Gryd.Unit(name=\"foot\") <Unit epsg=9002 ratio=3.2808693302666354> >>> float(Gryd.Unit(name=\"foot\")) 3.2808693302666354 Prime Objects class Prime(Epsg) Prime meridian. >>> prime = Gryd.Prime(epsg=8902) >>> prime <Prime meridian epsg=8902 longitude=-009\u00c2\u00b007'54.862\"> >>> prime.name 'Lisbon' Ellipsoid Objects class Ellipsoid(Epsg) Ellipsoid model. If initialized with no args nor keyword args, it is a 6378137-meters-radius sphere. >>> wgs84 = Gryd.Ellipsoid(\"WGS 84\") >>> wgs84 <Ellispoid epsg=7030 a=6378137.000000 1/f=298.25722356> distance | distance(lla0, lla1) Return Vincenty distance between two geodesic points. >>> london = Gryd.Geodesic(-0.127005, 51.518602, 0.) >>> dublin = Gryd.Geodesic(-6.259437, 53.350765, 0.) >>> wgs84.distance(dublin, london) <Distance 464.025km initial bearing=113.6 final bearing=118.5> Arguments : lla0 Gryd.Geodesic - point A lla1 Gryd.Geodesic - point B Returns : Gryd.Vincenty_dist structure destination | destination(lla, bearing, distance) Return Vincenty destination from geodesic start point folowing specific bearing for a determined distance. >>> wgs84.destination( ... london, math.degrees(vdist.final_bearing) + 180, vdist.distance ... ) <Destination lon=-006\u00c2\u00b015'33.973\" lat=+053\u00c2\u00b021'2.754\" end bearing=-66.4\u00c2\u00b0> >>> dublin <lon=-006\u00c2\u00b015'33.973\" lat=+053\u00c2\u00b021'2.754\" alt=0.000> Arguments : lla Gryd.Geodesic - start point bearing float - start bearing in degrees distance float - distance in meters Returns : Gryd.Vincenty_dest structure npoints | npoints(lla0, lla1, n) >>> for p in wgs84.npoints(dublin, londre, 4): print(p) ... <Destination lon=-006\u00c2\u00b015'33.973\" lat=+053\u00c2\u00b021'2.754\" end bearing=113.6> <Destination lon=-004\u00c2\u00b059'32.422\" lat=+053\u00c2\u00b000'36.687\" end bearing=114.6> <Destination lon=-003\u00c2\u00b044'43.501\" lat=+052\u00c2\u00b039'22.715\" end bearing=115.6> <Destination lon=-002\u00c2\u00b031'7.792\" lat=+052\u00c2\u00b017'22.201\" end bearing=116.6> <Destination lon=-001\u00c2\u00b018'45.650\" lat=+051\u00c2\u00b054'36.502\" end bearing=117.5> <Destination lon=-000\u00c2\u00b007'37.218\" lat=+051\u00c2\u00b031'6.967\" end bearing=118.5> Datum Objects class Datum(Epsg) >>> Gryd.Datum(epsg=4326) <Datum epsg=4326: <Ellispoid epsg=7030 a=6378137.000000 1/f=298.25722356> <Prime meridian epsg=8901 longitude=0.000000> to wgs84: 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0> xyz | xyz(lla) >>> wgs84.xyz(london) <X=3977018.848 Y=-8815.695 Z=4969650.564> lla | lla(xyz) >>> wgs84.lla(wgs84.xyz(london)) <lon=-000\u00c2\u00b007'37.218\" lat=+051\u00c2\u00b031'6.967\" alt=0.000> >>> london <lon=-000\u00c2\u00b007'37.218\" lat=+051\u00c2\u00b031'6.967\" alt=0.000> transform | transform(dst, lla) >>> airy = Gryd.Datum(epsg=4277) >>> wgs84.transform(airy, london) <lon=-000\u00c2\u00b007'31.431'' lat=+051\u00c2\u00b031'5.137'' alt=-46.118> Crs Objects class Crs(Epsg) >>> pvs = Gryd.Crs(epsg=3785) >>> osgb36 = Gryd.Crs(epsg=27700) >>> osgb36.datum.xyz(london) <X=3976632.017 Y=-8814.837 Z=4969286.446> >>> osgb36.datum.ellipsoid.distance(dublin, london) <Distance 463.981km initial bearing=113.6 final bearing=118.5> >>> osgb36 <Crs epsg=27700: <Datum epsg=4277: <Ellispoid epsg=7001 a=6377563.396000 1/f=299.32496460> <Prime meridian epsg=8901 longitude=0.000000> to wgs84 446.45,-125.16,542.06,-20.49,0.15,0.25,0.84> <Unit epsg=9001 ratio=1.0> Projection 'tmerc'> __reduce__ | __reduce__() special method that allows Gryd.Crs instance to be pickled __call__ | __call__(element) >>> osgb36(london) # projection of Geodesic point <X=529939.106 Y=181680.962s alt=0.000> >>> osgb36(osgb36(london)) # deprojection of Geographic point <lon=-000\u00c2\u00b007'37.218\" lat=+051\u00c2\u00b031'6.967\" alt=0.000> transform | transform(dst, xya) >>> osgb36.transform(pvs, osgb36(london)) <X=-14317.072 Y=6680144.273s alt=-13015.770> >>> pvs.transform(osgb36, osgb36.transform(pvs, osgb36(london))) <X=529939.101 Y=181680.963s alt=0.012> >>> osgb36(london) <X=529939.106 Y=181680.962s alt=0.000> add_map_point | add_map_point(px, py, point) >>> pvs.add_map_point(0,0, Geodesic(-179.999, 85)) >>> pvs.add_map_point(512,512, Geodesic(179.999, -85)) map2crs | map2crs(px, py, geographic=False) >>> pvs.map2crs(256+128, 256+128) <lon=+089\u00c2\u00b059'58.20'' lat=-066\u00c2\u00b023'43.74'' alt=0.000> >>> pvs.map2crs(256-128, 256+128, geographic=True) <point X=-10018698.512 Y=-9985934.440s alt=0.000> crs2map | crs2map(point) >>> pvs.crs2map(pvs.map2crs(256+128, 256+128)) <px=384 py=384 - <lon=+089\u00c2\u00b059'58.20'' lat=-066\u00c2\u00b023'43.74'' alt=0.000> - <X=10018698.512 Y=-9985934.440s alt=0.000> >","title":"API"},{"location":"api/#gryd","text":"EPSG dataset All epsg dataset linked to these projections are available through python API using epsg id or name: Mercator Transverse Mercator Lambert Conformal Conic. Miller Grids Four main grids are available: Universal Transverse Mercator Military Grid Reference System British National Grid Irish National Grid. Image-map interpolation Gryd.Crs also provides functions for map coordinates interpolation using calibration Points (two minimum are required). Quick view >>> import Gryd >>> dublin = Gryd.Geodesic(-6.259437, 53.350765, 0.) >>> dublin <lon=-006\u00c2\u00b015'33.973\" lat=+053\u00c2\u00b021'2.754\" alt=0.000> >>> utm = Gryd.Crs(epsg=3395, projection=\"utm\") >>> utm(dublin) <area=29U E=682406.211 N=5914792.531, alt=0.000> >>> mgrs = Gryd.Crs(epsg=3395, projection=\"mgrs\") >>> mgrs(dublin) <area=29U PV E=82406.211 N=14792.531, alt=0.000> >>> bng = Gryd.Crs(projection=\"bng\") >>> bng(dublin) <area=SG E=16572.029 N=92252.917, alt=0.000> >>> ing = Gryd.Crs(projection=\"ing\") >>> ing(dublin) <area=O E=15890.887 N=34804.964, alt=0.000>","title":"Gryd"},{"location":"api/#epsg_con","text":"Connection to epsg database","title":"EPSG_CON"},{"location":"api/#geocentric-objects","text":"class Geocentric(ctypes.Structure) ctypes structure for geocentric coordinates. This reference is generaly used as a transition for datum conversion. Attributes : x float - X-axis value y float - Y-axis value z float - Z-axis value >>> Gryd.Geocentric(4457584, 429216, 4526544) <X=4457584.000 Y=429216.000 Z=4526544.000> >>> Gryd.Geocentric(x=4457584, y=429216, z=4526544) <X=4457584.000 Y=429216.000 Z=4526544.000>","title":"Geocentric Objects"},{"location":"api/#point-objects","text":"class Point(ctypes.Structure) ctypes structure for calibration point. It is used for coordinates interpolation on a referenced raster image. Two points minimum are required. Attributes : px float - pixel column position py float - pixel row position lla Gryd.Geodesic - geodesic coordinates associated to the pixel coordinates xya Gryd.Geographic - geographic coordinates associated to the pixel coordinates","title":"Point Objects"},{"location":"api/#vincenty_dist-objects","text":"class Vincenty_dist(ctypes.Structure) Great circle distance computation result using Vincenty formulae. Vincenty_dist structures are returned by Gryd.Ellipsoid.distance function. Attributes : distance float - great circle distance in meters initial_bearing float - initial bearing in degrees final_bearing float - final bearing in degrees","title":"Vincenty_dist Objects"},{"location":"api/#vincenty_dest-objects","text":"class Vincenty_dest(ctypes.Structure) Great circle destination computation result using Vincenty formulae. Vincenty_dist structures are returned by Gryd.Ellipsoid.destination function. Attributes : longitude float - destinatin longitude in degrees latitude float - destination latitude in degrees destination_bearing float - destination bearing in degrees","title":"Vincenty_dest Objects"},{"location":"api/#dms-objects","text":"class Dms(ctypes.Structure) Degrees Minutes Seconde value of a float value. Dms structure are returned by Gryd.dms function. >>> d = Gryd.dms(-60.42286847222222) >>> d -060\u00c2\u00b025'22.326\" >>> float(d) -60.42286847222222","title":"Dms Objects"},{"location":"api/#dmm-objects","text":"class Dmm(ctypes.Structure) Degrees Minutes value of a float value. Dmm structure are returned by Gryd.dmm function. >>> d = Gryd.dmm(-60.42286847222222) >>> d -060\u00c2\u00b025.372108' >>> float(d) -60.42286847222222","title":"Dmm Objects"},{"location":"api/#epsg-objects","text":"class Epsg(ctypes.Structure) ctypes structure with a sqlite connection to EPSG database for initialization purpose.","title":"Epsg Objects"},{"location":"api/#sqlite","text":"Shared sqlite database to be linked with","title":"sqlite"},{"location":"api/#table","text":"The table database name where __init__ will find data","title":"table"},{"location":"api/#__init__","text":"| __init__(*args, **pairs) If list of values is given as *args , structure members are initialized in the order of the field definition. If *args only contains one value: it is a dict then it is used as a reccord it is an int then try to get a record from database using epsg id it is a str then try to get a record from database using epsg name All values in **pairs are merged in the record before attributes initialization.","title":"__init__"},{"location":"api/#unit-objects","text":"class Unit(Epsg) Unit ratio relative to meter. >>> Gryd.Unit(9001) <Unit epsg=9001 ratio=1.0> >>> Gryd.Unit(epsg=9001).name 'metre' >>> Gryd.Unit(name=\"foot\") <Unit epsg=9002 ratio=3.2808693302666354> >>> float(Gryd.Unit(name=\"foot\")) 3.2808693302666354","title":"Unit Objects"},{"location":"api/#prime-objects","text":"class Prime(Epsg) Prime meridian. >>> prime = Gryd.Prime(epsg=8902) >>> prime <Prime meridian epsg=8902 longitude=-009\u00c2\u00b007'54.862\"> >>> prime.name 'Lisbon'","title":"Prime Objects"},{"location":"api/#ellipsoid-objects","text":"class Ellipsoid(Epsg) Ellipsoid model. If initialized with no args nor keyword args, it is a 6378137-meters-radius sphere. >>> wgs84 = Gryd.Ellipsoid(\"WGS 84\") >>> wgs84 <Ellispoid epsg=7030 a=6378137.000000 1/f=298.25722356>","title":"Ellipsoid Objects"},{"location":"api/#distance","text":"| distance(lla0, lla1) Return Vincenty distance between two geodesic points. >>> london = Gryd.Geodesic(-0.127005, 51.518602, 0.) >>> dublin = Gryd.Geodesic(-6.259437, 53.350765, 0.) >>> wgs84.distance(dublin, london) <Distance 464.025km initial bearing=113.6 final bearing=118.5> Arguments : lla0 Gryd.Geodesic - point A lla1 Gryd.Geodesic - point B Returns : Gryd.Vincenty_dist structure","title":"distance"},{"location":"api/#destination","text":"| destination(lla, bearing, distance) Return Vincenty destination from geodesic start point folowing specific bearing for a determined distance. >>> wgs84.destination( ... london, math.degrees(vdist.final_bearing) + 180, vdist.distance ... ) <Destination lon=-006\u00c2\u00b015'33.973\" lat=+053\u00c2\u00b021'2.754\" end bearing=-66.4\u00c2\u00b0> >>> dublin <lon=-006\u00c2\u00b015'33.973\" lat=+053\u00c2\u00b021'2.754\" alt=0.000> Arguments : lla Gryd.Geodesic - start point bearing float - start bearing in degrees distance float - distance in meters Returns : Gryd.Vincenty_dest structure","title":"destination"},{"location":"api/#npoints","text":"| npoints(lla0, lla1, n) >>> for p in wgs84.npoints(dublin, londre, 4): print(p) ... <Destination lon=-006\u00c2\u00b015'33.973\" lat=+053\u00c2\u00b021'2.754\" end bearing=113.6> <Destination lon=-004\u00c2\u00b059'32.422\" lat=+053\u00c2\u00b000'36.687\" end bearing=114.6> <Destination lon=-003\u00c2\u00b044'43.501\" lat=+052\u00c2\u00b039'22.715\" end bearing=115.6> <Destination lon=-002\u00c2\u00b031'7.792\" lat=+052\u00c2\u00b017'22.201\" end bearing=116.6> <Destination lon=-001\u00c2\u00b018'45.650\" lat=+051\u00c2\u00b054'36.502\" end bearing=117.5> <Destination lon=-000\u00c2\u00b007'37.218\" lat=+051\u00c2\u00b031'6.967\" end bearing=118.5>","title":"npoints"},{"location":"api/#datum-objects","text":"class Datum(Epsg) >>> Gryd.Datum(epsg=4326) <Datum epsg=4326: <Ellispoid epsg=7030 a=6378137.000000 1/f=298.25722356> <Prime meridian epsg=8901 longitude=0.000000> to wgs84: 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0>","title":"Datum Objects"},{"location":"api/#xyz","text":"| xyz(lla) >>> wgs84.xyz(london) <X=3977018.848 Y=-8815.695 Z=4969650.564>","title":"xyz"},{"location":"api/#lla","text":"| lla(xyz) >>> wgs84.lla(wgs84.xyz(london)) <lon=-000\u00c2\u00b007'37.218\" lat=+051\u00c2\u00b031'6.967\" alt=0.000> >>> london <lon=-000\u00c2\u00b007'37.218\" lat=+051\u00c2\u00b031'6.967\" alt=0.000>","title":"lla"},{"location":"api/#transform","text":"| transform(dst, lla) >>> airy = Gryd.Datum(epsg=4277) >>> wgs84.transform(airy, london) <lon=-000\u00c2\u00b007'31.431'' lat=+051\u00c2\u00b031'5.137'' alt=-46.118>","title":"transform"},{"location":"api/#crs-objects","text":"class Crs(Epsg) >>> pvs = Gryd.Crs(epsg=3785) >>> osgb36 = Gryd.Crs(epsg=27700) >>> osgb36.datum.xyz(london) <X=3976632.017 Y=-8814.837 Z=4969286.446> >>> osgb36.datum.ellipsoid.distance(dublin, london) <Distance 463.981km initial bearing=113.6 final bearing=118.5> >>> osgb36 <Crs epsg=27700: <Datum epsg=4277: <Ellispoid epsg=7001 a=6377563.396000 1/f=299.32496460> <Prime meridian epsg=8901 longitude=0.000000> to wgs84 446.45,-125.16,542.06,-20.49,0.15,0.25,0.84> <Unit epsg=9001 ratio=1.0> Projection 'tmerc'>","title":"Crs Objects"},{"location":"api/#__reduce__","text":"| __reduce__() special method that allows Gryd.Crs instance to be pickled","title":"__reduce__"},{"location":"api/#__call__","text":"| __call__(element) >>> osgb36(london) # projection of Geodesic point <X=529939.106 Y=181680.962s alt=0.000> >>> osgb36(osgb36(london)) # deprojection of Geographic point <lon=-000\u00c2\u00b007'37.218\" lat=+051\u00c2\u00b031'6.967\" alt=0.000>","title":"__call__"},{"location":"api/#transform_1","text":"| transform(dst, xya) >>> osgb36.transform(pvs, osgb36(london)) <X=-14317.072 Y=6680144.273s alt=-13015.770> >>> pvs.transform(osgb36, osgb36.transform(pvs, osgb36(london))) <X=529939.101 Y=181680.963s alt=0.012> >>> osgb36(london) <X=529939.106 Y=181680.962s alt=0.000>","title":"transform"},{"location":"api/#add_map_point","text":"| add_map_point(px, py, point) >>> pvs.add_map_point(0,0, Geodesic(-179.999, 85)) >>> pvs.add_map_point(512,512, Geodesic(179.999, -85))","title":"add_map_point"},{"location":"api/#map2crs","text":"| map2crs(px, py, geographic=False) >>> pvs.map2crs(256+128, 256+128) <lon=+089\u00c2\u00b059'58.20'' lat=-066\u00c2\u00b023'43.74'' alt=0.000> >>> pvs.map2crs(256-128, 256+128, geographic=True) <point X=-10018698.512 Y=-9985934.440s alt=0.000>","title":"map2crs"},{"location":"api/#crs2map","text":"| crs2map(point) >>> pvs.crs2map(pvs.map2crs(256+128, 256+128)) <px=384 py=384 - <lon=+089\u00c2\u00b059'58.20'' lat=-066\u00c2\u00b023'43.74'' alt=0.000> - <X=10018698.512 Y=-9985934.440s alt=0.000> >","title":"crs2map"},{"location":"geodesy/","text":"Gryd.geodesy base32 base32(secret) Return a 32-length of unique bytes from secret hash. Geodesic Objects class Geodesic(ctypes.Structure) ctypes structure for geodesic coordinates Attributes : longitude float - longitude value of geodesic coordinates in degrees latitude float - latitude value of geodesic coordinates in degrees altitude float - elevation of the geodesic coordinates in meters >>> dublin = Gryd.Geodesic(-6.272877, 53.344606, 105.) >>> dublin <lon=-006\u00b016'22.357\" lat=+053\u00b020'40.582\" alt=105.000> encrypt | encrypt(digit, secret) Encrypt geodesic coordinates. It uses geohash with a custom 32-length base initialized by Gryd.geodesy.base32 . >>> g = Gryd.geodesy.Geodesic(-5.412300, 45.632100) >>> g.encrypt(23, \"secret\") b'\\xbda\\xe0\\xa3\\xe9\\xbd\\x1d\\x86\\xe0_a1\\x8bV2\\xe0aV\\xbd2\\xcd\\xe0\\xe0' Arguments : digit int - result bytes-length secret bytes or str - secret used to encrypt geodesic coordinates Returns : bytes data decrypt | @staticmethod | decrypt(encrypted, secret) Decrypt geodesic from encrypted. It uses geohash with a custem 32-length base initialized by Gryd.geodesy.base32 . >>> enc = b'\\xbda\\xe0\\xa3\\xe9\\xbd\\x1d\\x86\\xe0_a1\\x8bV2\\xe0aV\\xbd2\\xcd'\\ ... b'\\xe0\\xe0' >>> geo.Geodesic.decrypt(enc, \"secret\") <lon=-5.412300 lat=45.632100 alt=0.000> Arguments : encrypted bytes - encrypted geodesic coordinates secret bytes or str - secret used to encrypt geodesic coordinates Returns : Gryd.geodesy.Geodesic coordinates geohash | geohash(digit=10) Convert coordinates to geohash. >>> dublin.geohash() # by default on 10 digit for metric precision 'gc7x3r04z7' >>> dublin.geohash(14) # why not on 14 digit for millimetric precision 'gc7x3r04z77csw' Arguments : digit int - total digit to use in the geohash Returns : Geohash str from_geohash | @staticmethod | from_geohash(geoh) Return Geodesic object geohash. >>> Gryd.Geodesic.from_geohash('gc7x3r04z7') <lon=-006\u00b016'22.347\" lat=+053\u00b020'40.590\" alt=0.000> >>> Gryd.Geodesic.from_geohash('gc7x3r04z77csw') <lon=-006\u00b016'22.357\" lat=+053\u00b020'40.582\" alt=0.000> Arguments : geoh str - georef string Returns : Gryd.geodesy.Geodesic coordinates maidenhead | maidenhead(level=4) Convert coordinates to maidenhead. >>> dublin.maidenhead() 'IO63ui72gq' >>> dublin.maidenhead(level=6) 'IO63ui72gq19dh' Arguments : level int - precision level of maidenhead Returns : Maidenhead str from_maidenhead | @staticmethod | from_maidenhead(maidenhead) Return Geodesic object from maidenhead string. Arguments : maidenhead str - maidenhead string Returns : Gryd.geodesy.Geodesic coordinates georef | georef(digit=8) Convert coordinates to georef. >>> dublin.georef() 'MKJJ43322037' >>> dublin.georef(digit=6) 'MKJJ433203' Arguments : digit int - digit number of georef (can be 4, 6 or 8) Returns : Georef str from_georef | @staticmethod | from_georef(georef) Return Geodesic object from georef. >>> Gryd.Geodesic.from_georef('MKJJ43322037') <lon=-006\u00b016'21.900\" lat=+053\u00b020'41.100\" alt=0.000> >>> Gryd.Geodesic.from_georef('MKJJ433220') <lon=-006\u00b015'57.000\" lat=+053\u00b022'45.000\" alt=0.000> Arguments : georef str - georef string Returns : Gryd.geodesy.Geodesic coordinates gars | gars() Get the associated GARS Area (5minx5min tile). >>> dublin.gars() '348MY16' from_gars | @staticmethod | from_gars(gars, anchor=\"\") Return Geodesic object from gars. Optional anchor value to define where to handle 5minx5min tile. >>> Gryd.Geodesic.from_gars('348MY16', anchor=\"nw\") <lon=-006\u00b020'0.000\" lat=+053\u00b025'0.000\" alt=0.000> >>> Gryd.Geodesic.from_gars('348MY16') <lon=-006\u00b017'30.000\" lat=+053\u00b022'30.000\" alt=0.000> Arguments : gars str - gars string anchor str - tile anchor (nesw) Returns : Gryd.geodesy.Geodesic coordinates url_load_location | url_load_location(url, **kwargs) Return a static map image data from map provider. >>> # below a mapbox-static-map url centered on [lon, lat] with a red >>> # pin, width, height and zoom to be specified on call >>> url = \"https://api.mapbox.com/styles/v1/mapbox/outdoors-v11/static\" ... \"/pin-s+f74e4e(%(lon)f,%(lat)f)/%(lon)f,%(lat)f,%(zoom)d,0\" ... \"/%(width)dx%(height)d?access_token=%(token)s\" >>> data = dublin.url_load_location( ... url, zoom=15, width=600, height=400, token=\"xx-xxxxxx-xx\" ... ) >>> # see `Gryd.geodesy.Geodesic.dump_location` >>> with io.open(\"dump.png\", \"wb\") as f: ... f.write(data) Arguments : url str - map provider url containing %(lon)f and %(lat)f format expression to be replaced by longitude and latitude found in GPS data **kwargs dict - key-value pairs to match entries in url according to python string formatting Returns : Image data as bytes (py3) or str (py2) dump_location | dump_location(name, url, **kwargs) Dump a static map image from map provider into filesystem. Arguments : name str - a valid filepath url str - map provider url containing %(lon)f and %(lat)f format expression to be replaced by longitude and latitude found in GPS data **kwargs dict - key-value pairs to match entries in url according to python string formatting Gryd.geohash Efficient geohash computing library based on bitwise operation with python integer. >>> from Gryd import geohash >>> dublin = geohash.geoh(-6.272877, 53.344606, bits=50) >>> dublin <01111010110011111101000111011100000001001111100111> >>> geohash.as_str(dublin) 'gc7x3r04z7' Geohash can be encoded with a custom 32-element-sized base. >>> import random >>> base = list(\"0123456789bcdefghjkmnpqrstuvwxyz\") >>> random.shuffle(base) >>> base = \"\".join(base) >>> base 'tjcbwq2uev8n7r9gmdf1sy05kzxh4p63' >>> geohash.as_str(dublin, base=base) 'gnupb5tw3u' >>> geohash.as_int('gnupb5tw3u', base=base) <01111010110011111101000111011100000001001111100111> >>> dublin <01111010110011111101000111011100000001001111100111> EARTH_RADIUS Popular Visualisation Spheroid radius (epsg 7059 ellipsoid) GeoH Objects class GeoH(int) Integer that keeps info about leading zero bits. precision | precision() Return meter precision tuple for longitude and latitude based on Popular Visualisation Spheroid radius (epsg 7059 ellipsoid). geoh geoh(lon, lat, bits=25) Return a python integer representing geohashed coordinates longitude and latitude with a given precision. Arguments : lon float - longitude lat float - latitude bits int - length of the geohash in bit Returns : Gryd.geohash.GeoH lonlat lonlat(value, centered=False) Return longitude and latitude and precision from a geohash integer. Arguments : value Gryd.geohash.GeoH or int - geohash value centered bool - returns bottom-left corner (if False ) or center (if True ) of geohash surface Returns : longitude, latitude and precision as (dlon, dlat) tuple to_geohash backward compatibility from_geohash backward compatibility","title":"Geodesy"},{"location":"geodesy/#grydgeodesy","text":"","title":"Gryd.geodesy"},{"location":"geodesy/#base32","text":"base32(secret) Return a 32-length of unique bytes from secret hash.","title":"base32"},{"location":"geodesy/#geodesic-objects","text":"class Geodesic(ctypes.Structure) ctypes structure for geodesic coordinates Attributes : longitude float - longitude value of geodesic coordinates in degrees latitude float - latitude value of geodesic coordinates in degrees altitude float - elevation of the geodesic coordinates in meters >>> dublin = Gryd.Geodesic(-6.272877, 53.344606, 105.) >>> dublin <lon=-006\u00b016'22.357\" lat=+053\u00b020'40.582\" alt=105.000>","title":"Geodesic Objects"},{"location":"geodesy/#encrypt","text":"| encrypt(digit, secret) Encrypt geodesic coordinates. It uses geohash with a custom 32-length base initialized by Gryd.geodesy.base32 . >>> g = Gryd.geodesy.Geodesic(-5.412300, 45.632100) >>> g.encrypt(23, \"secret\") b'\\xbda\\xe0\\xa3\\xe9\\xbd\\x1d\\x86\\xe0_a1\\x8bV2\\xe0aV\\xbd2\\xcd\\xe0\\xe0' Arguments : digit int - result bytes-length secret bytes or str - secret used to encrypt geodesic coordinates Returns : bytes data","title":"encrypt"},{"location":"geodesy/#decrypt","text":"| @staticmethod | decrypt(encrypted, secret) Decrypt geodesic from encrypted. It uses geohash with a custem 32-length base initialized by Gryd.geodesy.base32 . >>> enc = b'\\xbda\\xe0\\xa3\\xe9\\xbd\\x1d\\x86\\xe0_a1\\x8bV2\\xe0aV\\xbd2\\xcd'\\ ... b'\\xe0\\xe0' >>> geo.Geodesic.decrypt(enc, \"secret\") <lon=-5.412300 lat=45.632100 alt=0.000> Arguments : encrypted bytes - encrypted geodesic coordinates secret bytes or str - secret used to encrypt geodesic coordinates Returns : Gryd.geodesy.Geodesic coordinates","title":"decrypt"},{"location":"geodesy/#geohash","text":"| geohash(digit=10) Convert coordinates to geohash. >>> dublin.geohash() # by default on 10 digit for metric precision 'gc7x3r04z7' >>> dublin.geohash(14) # why not on 14 digit for millimetric precision 'gc7x3r04z77csw' Arguments : digit int - total digit to use in the geohash Returns : Geohash str","title":"geohash"},{"location":"geodesy/#from_geohash","text":"| @staticmethod | from_geohash(geoh) Return Geodesic object geohash. >>> Gryd.Geodesic.from_geohash('gc7x3r04z7') <lon=-006\u00b016'22.347\" lat=+053\u00b020'40.590\" alt=0.000> >>> Gryd.Geodesic.from_geohash('gc7x3r04z77csw') <lon=-006\u00b016'22.357\" lat=+053\u00b020'40.582\" alt=0.000> Arguments : geoh str - georef string Returns : Gryd.geodesy.Geodesic coordinates","title":"from_geohash"},{"location":"geodesy/#maidenhead","text":"| maidenhead(level=4) Convert coordinates to maidenhead. >>> dublin.maidenhead() 'IO63ui72gq' >>> dublin.maidenhead(level=6) 'IO63ui72gq19dh' Arguments : level int - precision level of maidenhead Returns : Maidenhead str","title":"maidenhead"},{"location":"geodesy/#from_maidenhead","text":"| @staticmethod | from_maidenhead(maidenhead) Return Geodesic object from maidenhead string. Arguments : maidenhead str - maidenhead string Returns : Gryd.geodesy.Geodesic coordinates","title":"from_maidenhead"},{"location":"geodesy/#georef","text":"| georef(digit=8) Convert coordinates to georef. >>> dublin.georef() 'MKJJ43322037' >>> dublin.georef(digit=6) 'MKJJ433203' Arguments : digit int - digit number of georef (can be 4, 6 or 8) Returns : Georef str","title":"georef"},{"location":"geodesy/#from_georef","text":"| @staticmethod | from_georef(georef) Return Geodesic object from georef. >>> Gryd.Geodesic.from_georef('MKJJ43322037') <lon=-006\u00b016'21.900\" lat=+053\u00b020'41.100\" alt=0.000> >>> Gryd.Geodesic.from_georef('MKJJ433220') <lon=-006\u00b015'57.000\" lat=+053\u00b022'45.000\" alt=0.000> Arguments : georef str - georef string Returns : Gryd.geodesy.Geodesic coordinates","title":"from_georef"},{"location":"geodesy/#gars","text":"| gars() Get the associated GARS Area (5minx5min tile). >>> dublin.gars() '348MY16'","title":"gars"},{"location":"geodesy/#from_gars","text":"| @staticmethod | from_gars(gars, anchor=\"\") Return Geodesic object from gars. Optional anchor value to define where to handle 5minx5min tile. >>> Gryd.Geodesic.from_gars('348MY16', anchor=\"nw\") <lon=-006\u00b020'0.000\" lat=+053\u00b025'0.000\" alt=0.000> >>> Gryd.Geodesic.from_gars('348MY16') <lon=-006\u00b017'30.000\" lat=+053\u00b022'30.000\" alt=0.000> Arguments : gars str - gars string anchor str - tile anchor (nesw) Returns : Gryd.geodesy.Geodesic coordinates","title":"from_gars"},{"location":"geodesy/#url_load_location","text":"| url_load_location(url, **kwargs) Return a static map image data from map provider. >>> # below a mapbox-static-map url centered on [lon, lat] with a red >>> # pin, width, height and zoom to be specified on call >>> url = \"https://api.mapbox.com/styles/v1/mapbox/outdoors-v11/static\" ... \"/pin-s+f74e4e(%(lon)f,%(lat)f)/%(lon)f,%(lat)f,%(zoom)d,0\" ... \"/%(width)dx%(height)d?access_token=%(token)s\" >>> data = dublin.url_load_location( ... url, zoom=15, width=600, height=400, token=\"xx-xxxxxx-xx\" ... ) >>> # see `Gryd.geodesy.Geodesic.dump_location` >>> with io.open(\"dump.png\", \"wb\") as f: ... f.write(data) Arguments : url str - map provider url containing %(lon)f and %(lat)f format expression to be replaced by longitude and latitude found in GPS data **kwargs dict - key-value pairs to match entries in url according to python string formatting Returns : Image data as bytes (py3) or str (py2)","title":"url_load_location"},{"location":"geodesy/#dump_location","text":"| dump_location(name, url, **kwargs) Dump a static map image from map provider into filesystem. Arguments : name str - a valid filepath url str - map provider url containing %(lon)f and %(lat)f format expression to be replaced by longitude and latitude found in GPS data **kwargs dict - key-value pairs to match entries in url according to python string formatting","title":"dump_location"},{"location":"geodesy/#grydgeohash","text":"Efficient geohash computing library based on bitwise operation with python integer. >>> from Gryd import geohash >>> dublin = geohash.geoh(-6.272877, 53.344606, bits=50) >>> dublin <01111010110011111101000111011100000001001111100111> >>> geohash.as_str(dublin) 'gc7x3r04z7' Geohash can be encoded with a custom 32-element-sized base. >>> import random >>> base = list(\"0123456789bcdefghjkmnpqrstuvwxyz\") >>> random.shuffle(base) >>> base = \"\".join(base) >>> base 'tjcbwq2uev8n7r9gmdf1sy05kzxh4p63' >>> geohash.as_str(dublin, base=base) 'gnupb5tw3u' >>> geohash.as_int('gnupb5tw3u', base=base) <01111010110011111101000111011100000001001111100111> >>> dublin <01111010110011111101000111011100000001001111100111>","title":"Gryd.geohash"},{"location":"geodesy/#earth_radius","text":"Popular Visualisation Spheroid radius (epsg 7059 ellipsoid)","title":"EARTH_RADIUS"},{"location":"geodesy/#geoh-objects","text":"class GeoH(int) Integer that keeps info about leading zero bits.","title":"GeoH Objects"},{"location":"geodesy/#precision","text":"| precision() Return meter precision tuple for longitude and latitude based on Popular Visualisation Spheroid radius (epsg 7059 ellipsoid).","title":"precision"},{"location":"geodesy/#geoh","text":"geoh(lon, lat, bits=25) Return a python integer representing geohashed coordinates longitude and latitude with a given precision. Arguments : lon float - longitude lat float - latitude bits int - length of the geohash in bit Returns : Gryd.geohash.GeoH","title":"geoh"},{"location":"geodesy/#lonlat","text":"lonlat(value, centered=False) Return longitude and latitude and precision from a geohash integer. Arguments : value Gryd.geohash.GeoH or int - geohash value centered bool - returns bottom-left corner (if False ) or center (if True ) of geohash surface Returns : longitude, latitude and precision as (dlon, dlat) tuple","title":"lonlat"},{"location":"geodesy/#to_geohash","text":"backward compatibility","title":"to_geohash"},{"location":"geodesy/#from_geohash_1","text":"backward compatibility","title":"from_geohash"},{"location":"grids/","text":"Gryd.bng Gryd.ing Gryd.mgrs Gryd.utm","title":"Grids"},{"location":"grids/#grydbng","text":"","title":"Gryd.bng"},{"location":"grids/#gryding","text":"","title":"Gryd.ing"},{"location":"grids/#grydmgrs","text":"","title":"Gryd.mgrs"},{"location":"grids/#grydutm","text":"","title":"Gryd.utm"}]}